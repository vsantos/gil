package main

import (
	"context"
	"errors"
	"fmt"
	"gil/calculator"
	"gil/pricer"
	"gil/services"
	"log"
	"math"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

var instanceTypes []string

const REGION = "sa-east-1"
const NAMESPACE = "kong-system"
const APPSELECTOR = "app=ingress-kong"

func main() {
	// List price for every AWS instance
	var awsPrices pricer.Pricer
	awsPrices = &pricer.ProviderAWS{}
	priced := awsPrices.List()

	c, err := kubernetes.NewKubeClient("", "")
	if err != nil {
		log.Panic(err)
	}

	// Get prices for all nodes within a specific cluster
	nodes, err := GetNodes(c, context.TODO())
	if err != nil {
		fmt.Println(err)
	}

	// Endup with a list of all instance types used within a specific cluster
	// var cn []kubernetes.ClusterNode
	// var cns map[string]kubernetes.ClusterNode
	cns := make(map[string]kubernetes.ClusterNode)
	for _, node := range nodes {
		hostType := node.Labels["node.kubernetes.io/instance-type"]
		instanceTypes = append(instanceTypes, hostType)

		cns[node.Name] = kubernetes.ClusterNode{
			Type:           hostType,
			Region:         REGION,
			Resources:      priced[hostType].Resources,
			CalculatedCost: calculator.CalculateNodePrice(priced[hostType].Cost.RegionalCost.Value[REGION]),
		}
	}

	if len(cns) == 0 {
		log.Panic(errors.New("Empty list of node prices"))
	}

	// Based on every instance type within a specific cluster, get it's general price

	fmt.Println(cns)

	// Now we can get all deployments
	deployments, err := GetDeployments(c, context.TODO(), NAMESPACE, APPSELECTOR)
	if err != nil {
		log.Panic(err)
	}

	for _, deployment := range deployments {
		if *deployment.Spec.Replicas != 0 {
			fmt.Println("Deployment: ", deployment.Name)
			rc, err := GetCPURequest(deployment)
			if err != nil {
				fmt.Println("error: ", err)
			}

			fmt.Println("Requests CPU: ", rc)

			rm, err := GetMemoryRequest(deployment)
			if err != nil {
				fmt.Println("error: ", err)
			}

			fmt.Println("Requests Memory: ", rm)

			pods, err := GetPods(c, context.TODO(), NAMESPACE, APPSELECTOR)
			if err != nil {
				fmt.Println("error: ", err)
			}

			fmt.Println("Associated pods num: ", len(pods))
			var podSumPrices calculator.NodePrice
			for _, pod := range pods {
				rPrices, err := ReturnPodPrice(*deployment.Spec.Replicas, rc, rm, pod.Spec.NodeName, cns)
				if err != nil {
					log.Panic(err)
				}

				podSumPrices.Hourly += rPrices.Hourly
				podSumPrices.Daily += rPrices.Daily
				podSumPrices.Weekly += rPrices.Weekly
				podSumPrices.Monthly += rPrices.Monthly
				podSumPrices.Yearly += rPrices.Yearly

				fmt.Println(pod.Name)
				fmt.Println("cost per pod: ", rPrices)
			}

			fmt.Println("cost per deployment: ", podSumPrices)
		}

	}
}

func ReturnPodPrice(replicas int32, podRequestCPU int64, podRequestMem int64, scheduledNode string, nodes map[string]kubernetes.ClusterNode) (calculator.NodePrice, error) {
	if nodes[scheduledNode].Resources.VCPU == 0 || nodes[scheduledNode].Resources.MemoryGB == 0 {
		return calculator.NodePrice{}, errors.New(fmt.Sprintf("empty VCPU and/org Memory attributes for node %s", scheduledNode))
	}

	memUsagePercentRounded := CalculatePercentageOfUsage(float32(podRequestMem), nodes[scheduledNode].Resources.MemoryGB)

	c := CalculatePodPriceByUsage(memUsagePercentRounded, nodes[scheduledNode].CalculatedCost)
	fmt.Println("original cost:", nodes[scheduledNode].CalculatedCost.Hourly)
	fmt.Println("percent of cost:", c.Hourly)

	return c, nil
}

func PercentageChange(percent float32, total float32) float32 {
	return ((percent / 100) * total)
}

func CalculatePodPriceByUsage(memUsagePercentRounded float32, nodePrice calculator.NodePrice) calculator.NodePrice {
	return calculator.NodePrice{
		Hourly:  float64(PercentageChange(memUsagePercentRounded, float32(nodePrice.Hourly))),
		Daily:   float64(PercentageChange(memUsagePercentRounded, float32(nodePrice.Daily))),
		Weekly:  float64(PercentageChange(memUsagePercentRounded, float32(nodePrice.Weekly))),
		Monthly: float64(PercentageChange(memUsagePercentRounded, float32(nodePrice.Monthly))),
		Yearly:  float64(PercentageChange(memUsagePercentRounded, float32(nodePrice.Yearly))),
	}
}

func CalculatePercentageOfUsage(memPodRequestBytes float32, memoryNodeGB float32) float32 {
	var memPodRequestMB float32
	var bytes float32
	bytes = 1024

	memPodRequestMB = ((memPodRequestBytes / bytes) / bytes)
	memoryNodeMB := (memoryNodeGB * 1024)
	memUsagePercent := (memPodRequestMB / memoryNodeMB) * float32(100)
	memUsagePercentRounded := math.Round(float64(memUsagePercent*100)) / 100

	fmt.Println(memPodRequestMB)
	fmt.Println(memoryNodeMB)
	fmt.Println("% naked:", memUsagePercent)
	fmt.Println("% round:", memUsagePercentRounded)

	return float32(memUsagePercentRounded)
}

func GetDeployments(clientset *kubernetes.Clientset, ctx context.Context, namespace string, selector string) ([]appsv1.Deployment, error) {

	list, err := clientset.AppsV1().Deployments(namespace).List(ctx, metav1.ListOptions{
		LabelSelector: selector,
	})
	if err != nil {
		return nil, err
	}
	return list.Items, nil
}

func GetPods(clientset *kubernetes.Clientset, ctx context.Context, namespace string, selector string) ([]corev1.Pod, error) {

	list, err := clientset.CoreV1().Pods(namespace).List(ctx, metav1.ListOptions{
		LabelSelector: selector,
	})
	if err != nil {
		return nil, err
	}
	return list.Items, nil
}

func GetCPURequest(d appsv1.Deployment) (requested int64, err error) {
	var cpu int64
	var cpuIsOK bool
	var unscaledOk bool

	isCPUZero := d.Spec.Template.Spec.Containers[0].Resources.Requests.Cpu().IsZero()
	if isCPUZero {
		return 0, errors.New(fmt.Sprint("could not find CPU for: ", d.Spec.Template.Spec.Containers[0].Name))
	}

	if !isCPUZero {
		cpu, cpuIsOK = d.Spec.Template.Spec.Containers[0].Resources.Requests.Cpu().AsInt64()
		if !cpuIsOK {
			cpu, unscaledOk = d.Spec.Template.Spec.Containers[0].Resources.Requests.Cpu().AsDec().Unscaled()
			if !unscaledOk {
				return 0, errors.New(fmt.Sprint("could not get unscaled metrics for ", d.Spec.Template.Spec.Containers[0].Name))
			}

		}
	}

	return cpu, nil
}

func GetMemoryRequest(d appsv1.Deployment) (requested int64, err error) {
	var memory int64
	var memoryIsOK bool
	var unscaledOk bool

	isMemoryZero := d.Spec.Template.Spec.Containers[0].Resources.Requests.Memory().IsZero()
	if isMemoryZero {
		return 0, errors.New(fmt.Sprint("could not find Memory for: ", d.Spec.Template.Spec.Containers[0].Name))
	}

	if !isMemoryZero {
		memory, memoryIsOK = d.Spec.Template.Spec.Containers[0].Resources.Requests.Memory().AsInt64()
		if !memoryIsOK {
			memory, unscaledOk = d.Spec.Template.Spec.Containers[0].Resources.Requests.Memory().AsDec().Unscaled()
			if !unscaledOk {
				return 0, errors.New(fmt.Sprint("could not get unscaled metrics for ", d.Spec.Template.Spec.Containers[0].Name))
			}

		}
	}

	return memory, nil
}

func GetNodes(clientset *kubernetes.Clientset, ctx context.Context) ([]corev1.Node, error) {
	list, err := clientset.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	return list.Items, nil
}

func unique(s []string) []string {
	inResult := make(map[string]bool)
	var result []string
	for _, str := range s {
		if _, ok := inResult[str]; !ok {
			inResult[str] = true
			result = append(result, str)
		}
	}
	return result
}
